# [백엔드 스터디 in 큐시즘 - B조] WEEK 1: 스프링의 개념과 Golang 과 아이스브레이킹

# Spring Study
## 1. 스프링이란 무엇인가?
- 자바 엔터프라이즈 애플리케이션 개발에 사용된 프레임워크. 즉, **애플리케이션 개발을 빠르고 효율적으로 할 수 있도록 틀과 공통 프로그래밍 모델, 기술 API 등을 제공한다.

## 2. 스프링과 스프링 부트의 차이점은 무엇인가?
스프링 프레임워크는 기능이 많은만큼 환경설정이 복잡하다. 이에 어려움을 느끼는 사용자들을 위해 나온 것이 바로 **스프링 부트**이다. 

스프링 부트와 스프링 프레임워크와 몇 가지 면에서 차이점이 있다.
> **1.** 스프링 부트는 Embed Tomcat을 사용하기 때문에 따로 Tomcat을 설치하거나 매번 버전 관리를 해주어야 하는 수고로움을 덜어준다.

> **2.** 스프링 프레임워크는 각각의 dependency들의 호환되는 버전을 일일이 맞추어야 했고, 때문에 하나의 버전을 올리고자 하면 다른 dependency에 까지 영향을 미쳐 version 관리에 어려움이 많았다. 하지만 스프링 부트는 starter가 대부분의 dependency를 관리해주기 때문에 이러한 걱정을 많이 덜게 되었다.

> **3.** XML 설정을 하지 않아도 된다.

> **4.** jar file을 이용해 자바 옵션만으로 손쉽게 배포가 가능하다.

## 3. 프레임워크와 라이브러리의 차이점은 무엇인가?
프레임워크는 애플리케이션을 개발하는데 있어 기본적으로 필요한 구조와 구성을 갖추고 있어 개발자가 기능 구현에 집중할 수 있도록 한다. 프레임워크에서 뼈대를 제공하고 그 위에 개발자가 코드를 올려 동작하게끔 한다. 쉽게 비유하자면 **"설계는 내가 할게, 너는 구현만 해"** 라고 보면 될 것 같다.

라이브러리는 **개발을 하기 위해 필요한 것들을 미리 구현해놓은 대상, 도구**이다. 재사용이 가능한 기능을 미리 구현해놓고 필요한 곳에서 호출하여 사용할 수 있도록 만들어진 집합들을 말한다.

쉽게 비교하면 **프레임워크는 틀**이고 그 안에서 **재사용이 가능하도록 만들어진 도구를 라이브러리**라고 한다.

프레임워크와 라이브러리의 가장 큰 차이점은 흐름을 누가 가지고 있느냐에 있다. 프레임워크는 스스로 흐름을 가지고 있어 사용자로 하여금 코드를 연결할 공간을 강제하지만 라이브러리를 사용할 때에는 사용자가 흐름을 직접 제어하게 한다. 어디서, 언제 호출할지 사용자가 결정짓게 되는 것이다.

## 4. 스프링 프레임워크의 특징은 무엇인가?
### 4.1 POJO(Plain Old Java Object) 기반의 구성
스프링은 내부적으로 별도의 API를 사용하지 않고, 일반적인 Java 코드를 이용하여 객체를 구성하는 방식 그대로 사용하고 있다. 이것은 코드를 개발할 떄, 개발자가 특정한 라이브러리나 컨테이너의 기술에 종속적이지 않다 라는 것을 의미한다.

### 4.2 트랜잭션의 지원
DB를 연동하여 사용할 때 반드시 신경써야 하는 부분은 트랜잭션 부분이다. 상황에 따라 여러 코드를 작업해줘야 하는데, 스프링에서는 Annotation이나 XML로 설정할 수 있도록 지원해준다.

### 4.3 DI(Dependency Injection, 의존성 주입)
스프링에서는 'ApplicationContext' 라는 존재가 필요한 객체들을 생성하고, 필요한 객체들을 주입하는 역할을 해 주는 구조이다. 따라서 스프링을 사용하면 객체와 객체를 분리해서 생성하고, 이런 객체들을 엮는 작업을 하게 된다.

### 4.4 AOP(Aspect Oriented Programming, 관점 지향 프로그래밍)
흩어진 공통 기능들을 모듈화 하고, 쓰이는 곳에 필요할 때 연결함으로써 유지보수 혹은 재사용성을 더욱 높이는 관점 지향 프로그래밍을 지원한다.

## 5. 스프링 프레임워크 외에 다른 프레임워크와의 차별점은 무엇인가?
확장성이라고 생각한다. 스프링 프레임워크에 통합하기 위해 간단하게 기존 라이브러리를 감싸는 정도로 스프링에서 사용이 가능하기 때문에 수많은 라이브러리가 이미 스프링에서 지원되고 있는, 그리고 스프링에서 사용되는 라이브러리를 별도로 분리하기도 용이하다.

# GO Study

## 1. Go의 역사
Go 언어는 2009년 발표된 오픈 소스 프로그래밍 언어이다. 무료로 사용할 수 있고, 누구나 내부 구조를 살펴볼 수 있다.

오픈 소스 허브인 깃허브에 올라간 소스 코드 중 가장 많이 사용되는 언어 5위에 랭크될 만큼 많이 사용된다.

## 2. Go 언어 특징
> 1. **클래스가 없다.** - 클래스는 없지만. 매서드를 가지는 구조체를 지원
> 2. **상속이 없다.** - 상속을 지원하지 않는다.
> 3. **제네릭 프로그래밍을 지원하지 않는다.**

## 3. Hello Go World 코드 뜯어보기
```go
package main //1

import "fmt" //2

func main() { //3
  fmt.Println("Hello Go World") //4
}
```
> 1. package main
> Go 언어의 모든 코드는 반드시 패키지 선언으로 시작해야 한다. 또한 **main 패키지**는 **프로그램 시작점을 포함**하는 특별한 패키지이다.

> 2. import 'fmt'
> fmt 패키지를 가져온다. fmt 패키지는 표준 입출력을 다루는 내장 패키지이다. 표준 입출력으로 텍스트를 출력하거나 입력받을 때 사용한다.

> 3. func main()
> main() 함수는 프로그램 진입점 함수이다. 그래서 프로그램은 항상 main() 함수에서 시작한다. 즉 Go 언어로 만든 모든 프로그램은 main() 함수부터 시작되고 main() 함수가 종료되면 프로그램이 종료된다. 즉, 프로그램의 시작과 끝이 main() 함수이다.

> 4. fmt.Println("Hello Go World")
> fmt.Println() 는 표준 출력으로 문자열을 출력하는 함수이다. fmt.Println("Hello Go World")는 Hello Go World를 출력한다.

## 4. 변수

### 4.1 Golang의 변수 선언과 출력 코드

```go
package main

import "fmt"

func main() {
	var a int = 10
	var msg string = "Hello Variable"
	
	a = 20
	msg = "Good Morning"
	fmt.Println(msg, a)
}
```

위의 코드는 Golang 언어에서 볼 수 있는 변수 선언과 출력 코드이다. 코딩을 하면 다른 언어와는 다르다는 것을 바로 알 수 있을 것이다.

기본적인 Golang 에서의 변수 선언은 아래와 같다.

```go
var a int = 10
```

**var**는 변수의 영문인 variable 의 약자로 변수 선언을 알리는 키워드이다. 이어서 변수의 이름을 적는다. 그다음 타입을 적고 대입 연산자 = 오른쪽에 초깃값을 적어서 변수 선언을 마친다.

변수 선언을 알리는 키워드를 먼저 적는것도 그렇고, 변수의 이름 뒤에 변수 타입을 적는다는 것이 굉장히 생소하다.

다른 코드를 한번 보겠다.

```go
package main

import "fmt"

func main() {
	var minimumWage int = 10
	var workingHour int = 20

	var income int = minimumWage * workingHour

	fmt.Println(minimumWage, workingHour, imcome)
}
```

그리고 ; 가 없는것 또한 굉장히 눈에 띄는 특징이다.

### 4.2 변수 선언의 다른 형태

Go 언어에서는 프로그래머의 편의를 위해 여러 형태의 변수 선언을 지원한다. 

```go
package main

import "fmt"

func main() {
	var a int = 3// 기본 형태  
	var b int    // 초깃값 생략. 초깃값은 타입별 기본값으로 대체 
	var c = 4    // 타입 생략. 변수 타입은 우변 값의 타입이 됨
	d := 5       // 선언 대입문 := 을 사용해서 var 키워드와 타입 생략

//출력값: 3 0 4 5
```

Go 언어는 타입별 기본값이 정해진것 같다. 변수를 선언할 때 초깃값을 생략하면 아래 표와 같은 기본값이 자동으로 대입된다고 한다.

|        타입 |        기본값 |
| --- | --- |
| 모든 정수 타입 | 0 |
| 모든 실수 타입 | 0.0 |
| 불리언 | false |
| 문자열 | "”(빈 문자열) |
| 그의  | nil |

Go 함수에서는 **타입을 생략할 수** 있다. 타입을 생략하게 되면 우변의 타입으로 좌변(변수)의 타입이 지정된다. 만약 우변이 숫자이면 기본 타입으로 결정된다. 정수는 Int, 실수는 float64가 기본 타입이다.

그리고 제일 눈에 띄는게 있다면 **선언 대입문 :=** 이다.  선언 대입문이란 말 그대로 선언과 대입을 한꺼번에 하는 구문이다. 선언 대입문을 사용하면 var 키워드와 타입을 생략해 변수를 선언할 수 있다.

```go
var b = 3.1415     //b는 float64 타입으로 자동 지정
c := 365           //c는 int 타입으로 자동 지정
s := "hello world" // s는 string 타입으로 자동 지정
```

### 4.3 타입 변환

프로그래밍 언어를 구분할 때 타입 검사를 하는가 안 하는가에 따라 강 타입 언어와 약 타입 언어로 나눈다. Go 언어는 강 타입 언어 중에서도 가장 강하게 타입 검사를 하는 최강 타입 언어이다.

Go 언어에서는 연산이나 대입에서 타입이 다르면 에러가 발생한다.

```go
a := 3                //int
var b float64 = 3.5   //float64

var c int = b         //Error - float64 변수를 int에 대입 불가
d := a * b            //Error - 다른 타입인 int 변수와 float64 연산 불가

var e int64 = 7 
f := a * e            //Error - a는 int 타입, e는 int64 타입으로 같은 정수값이지만 
                      //타입이 달라서 연산 불가

var g int = b * 3     //Error - 실수가 정수로 자동으로 바뀌지 않는다
```

같은 숫자라도 타입이 다르면 연산이 안되기 때문에 타입을 변환해서 연산을 해줘야 한다. 이것을 **타입 변환**이라고 한다.

타입 변환을 이용해서 위의 코드를 에러 없이 다시 써보면 다음과 같다.

```go
package main

import "fmt"

func main() {
	a := 3                  //int
	var b float64 = 3.5     //float64

	var c int = int(b)      //float64에서 int로 변환
	d := flaot64(a * c)     //int에서 float64로 변환

	var e int64 = 7
	f := int64(d) * e       //float64에서 int64로 변환

	var g int = int(b * 3)  //float64에서 int로 변환
	var h int = int(b) * 3  //float64에서 int로 변환. g와 값이 다르다.
	fmt.Println(g, h, f)
}
```

타입 변환 시 두 가지 유의점이 있다.

첫째, 실수 타입에서 정수 타입으로 타입이 변환하면 소수점 이하 숫자가 없어진다는 점이다. 그래서 위의 코드에서 c값은 3.5에서 소수점 이하 숫자가 사리진 3이 된다. 소수점 이하의 숫자는 반올림되지 않고 버려진다. 

둘째, 큰 범위를 갖는 타입에서 작은 범위를 갖는 타입으로 변환하면 값이 달라질 수 있다. 아래 코드를 보겠다.

```go
package main

import "fmt"

func() main{
	var a int16 = 3456
	var c int8 = int8(a)
	
	fmt.Println(a)
	fmt.Println(c)
}
//출력값
//3456
//-128
```

타입 변환을 했더니 c값이 3456에서 -128로 변했다. 2바이트 정수 int16에서 1바이트 정수 int8로 변환할 때 상위 1바이트가 없어지기 때문이다.

### 4.4 변수의 범위

변수는 자신이 속한 중괄호 {} 범위를 벗어나면 사라진다. 범위 예제 코드를 보자.

```go
package main

import "fmt"  

var g int = 10 //패키지 전역 변수 선언

func main() {
	var m int = 20 //지역 변수 선언

	{
		var s int = 50  //지역 변수 선언
		fmt.Println(m, s, g)
	} //s 지역 변수는 사라짐
	
	m = s + 20 //Error
}
```

예제에서 어떤 중괄호에도 속해 있지 않은 g 변수는 패키지 전역 변수로 같은 패키지 내에서는 어디서나 접근할 수 있다. m 변수는 main() 함수에 속해 있는 지역 변수로 선언 이후부터 main() 함수가 끝나는 부분까지 접근할 수 있다. s 변수는 속해 있는 중괄호 {}가 끝나는 지점에서 사라진다. 그래서 마지막 m = s + 20 명령어에서 오류가 난다.
